Tema 1 - Dataplane Router
De Racolta Andrei-Vlad 325CD

In aceasta tema am avut de implementat un dataplane router care sa poata procesa pachete de tipul IPv4, ARP si ICMP. Pentru a realiza acest lucru, am folosit urmatoarele functii:

'compare': Aceasta functie este folosita pentru a sorta pachetele in functie de prioritatea lor.
Mai intai, verificam daca masca si prefixul celor doua rute sunt egale. Daca da, atunci verificam daca masca primului router este mai mare decat cea de a doua. Daca da, returnam 0, altfel returnam 1. Daca masca si prefixul sunt diferite, atunci verificam daca masca si prefixul primului router este mai mare decat cea de a doua. Daca da, returnam 0, altfel returnam 1. Folosim ntohl pentru a converti adresele in formatul host si pentru a le aranja in ordinea corecta.

'get_best_route': Aceasta functie este modul standard, preluat din laborator, pentru a face lookup
in tabela de rutare. Aceasta parcurge toate rutele si verifica daca adresa IP si masca rutei date se
potrivesc cu prefixul rutei. Daca se potrivesc, atunci se verifica daca aceasta ruta cea mai
buna este goala sau daca masca rutei curente este mai mare decat cea a rutei cea mai buna. Daca da,
atunci ruta cea mai buna devine ruta curenta. In final, se returneaza ruta cea mai buna. Aceasta solutie NU o folosesc in tema, caci foloseste un algoritm de cautare liniara, in loc de unul de cautare binara sau cautare de tip trie.

'get_best_route_binary_search': Aceasta functie este folosita pentru a face lookup in tabela de rutare, dar in loc sa folosim cautare liniara, folosim cautare binara. Setam left la 0 si right la
numarul de rute - 1. Cat timp left este mai mic sau egal cu right, calculam mijlocul: (left + right) / 2. Daca adresa IP si masca rutei de la mijloc se potrivesc cu prefixul si masca rutei de la mijloc, atunci verificam daca ruta cea mai buna este goala sau daca masca rutei din mijloc este mai mare decat cea a rutei cea mai buna. Daca da, atunci ruta cea mai buna devine ruta curenta, iar right devine mijloc - 1. Daca adresa IP si masca rutei de la mijloc e mai mare decat prefixul rutei de la mijloc, atunci right devine mijloc - 1. Altfel, left devine mijloc + 1. In final, se returneaza ruta cea mai buna. Aceasta functie are o cautare mai eficienta decat cea liniara, in cazul in care avem un numar mare de rute. Aceasta functie este folosita in tema si trece testele
forward10packets si forward10across.

'get_arp_entry': Aceasta functie este folosita pentru a gasi o intrare in tabela ARP. Parcurgem toate intrarile din tabela ARP si verificam daca adresa IP a intrarii este egala cu adresa IP data. Daca da, atunci returnam intrarea. Daca nu gasim nicio intrare, atunci returnam NULL.

'make_arp_request': Aceasta functie este folosita pentru a crea un pachet de tip ARP Request. Vom
crea un buffer nou de marimea 98(14 pentru headerul Ethernet, 20 pentru headerul ARP si 64 pentru
payload). Vom seta un mac cu 6 octeti si luam interfata rutei celei mai bune. Copiem adresa respectiva in sursa, iar destinatia o setam ca fiind cea de broadcast(FF:FF:FF:FF:FF:FF). Dupa, creem un header ARP. Setam tipul de hardware la 1(Ethernet), tipul de protocol la 0x0800(ETHERTYPE_IP), lungimea hardware la 6 si lungimea protocol la 4. Setam operatia la 1(ARP_REQUEST). Copiem adresa MAC a sursei si adresa IP a sursei in campurile corespunzatoare. Adresa MAC a destinatiei o setam cu 6 octeti de 0. Adresa IP a destinatiei o setam cu adresa IP a rutei celei mai bune. In final, trimitem pachetul ARP Request, folosind send_to_link. Odata implementata, imi trece testul router_arp_request.

'arp_reply': Aceasta functie este folosita pentru a trimite un pachet de tip ARP Reply. Mai intai, verificam daca operatia din pachetul ARP este 1 (ARP_REQUEST). Daca nu, atunci returnam. Daca da, atunci creem un buffer nou de marimea 98(14 pentru headerul Ethernet, 20 pentru headerul ARP si 64 pentru payload). Vom seta un nou ethernet header, cu noul buffer, si setam tipul de protocol la 0x0806(ETHERTYPE_ARP). Din nou, luam un mac de 6 octeti si luam interfata rutei celei mai bune. Copiem adresa MAC a sursei in sursa, iar destinatia o setam ca fiind adresa MAC a sursei. Dupa, creem un header ARP. Setam tipul de hardware la 1(Ethernet), tipul de protocol la 0x0800(ETHERTYPE_IP), lungimea hardware la 6 si lungimea protocol la 4. Setam operatia la 2(ARP_REPLY). Copiem adresa MAC a sursei si adresa IP a sursei in campurile corespunzatoare. Copiem adresa MAC a destinatiei si adresa IP a destinatiei in campurile corespunzatoare. In final, trimitem pachetul ARP Reply, folosind send_to_link. Odata implementata, imi trece testul router_arp_reply.

'icmp_error': Aceasta functie este folosita pentru a transmite o eroare de doua tipuri: Destination unreachable si Time exceeded. Mai intai, declaram eth_hdr si ip_hdr si le setam cu pachetul primit. Apoi vom crea un nou buffer de marime 98(14 pentru headerul Ethernet, 20 pentru headerul IP si 64 pentru payload). Vom seta un nou ethernet header, cu noul buffer, si setam tipul de protocol la 0x0800(ETHERTYPE_IP). Din nou, luam un mac de 6 octeti si luam interfata rutei celei mai bune. Copiem adresa MAC a sursei in sursa, iar destinatia o setam ca fiind adresa MAC a sursei. Dupa, creem un nou header IP. Setam versiunea la 4, IHL la 5, TOS la 0, lungimea totala la struct ip_hdr + 64, ID la 1, offset la 0, TTL la 64 si protocol la 1(ICMP). Dupa, facem rost de interfata rutei celei mai bune si setam adresa IP a sursei cu adresa IP a interfetei. Adresa IP a destinatiei o setam cu adresa IP a sursei din pachetul primit. Setam checksumul la 0. Dupa, creem un header ICMP. Setam tipul la 3(Destination unreachable) sau 11(Time exceeded), codul la 0 si checksumul la 0. In final, trimitem pachetul ICMP, folosind send_to_link. Odata implementata, imi trece testele host_unreachable si icmp_timeout.

'echo_reply': Aceasta functie este folosita pentru a transmite un pachet de tip ICMP Echo Reply. Mai intai, declaram ip_hdr si il setam la pachetul primit. Apoi, vom crea un buffer nou de marimea 98 (14 pentru headerul Ethernet, 20 pentru headerul IP si 64 pentru payload). Vom seta un nou IP header cu noul buffer si setam lungimea totala ca fiind ip_hdr + 64. Acum, vom crea un icmp_hdr si setam tipul la 0(ICMP_ECHO_REPLY), codul la 0 si checksumul la 0. In final, trimitem pachetul ICMP Echo Reply, folosind send_to_link. Odata implementata, imi trece testul router_icmp.

'handle_packet': Aceasta functie este inima intregului cod, iar fara el nu am avea nimic. Aceasta face procesul de dirijare a pachetelor. Mai intai, declaram eth_hdr si il setam la pachetul primit.Daca lungimea pachetului este mai mica decat cea a ether_headerului, atunci sarim peste acel pachet.Daca tipul de protocol este 0x0800(ETHERTYPE_IP), atunci declaram ip_hdr si il setam la pachetul primit. Daca checksumul este gresit(diferit de 0), atunci sarim peste acel pachet. Apoi, apelam 'get_best_route_binary' pentru a gasi cea mai buna ruta. Daca nu gasim nicio ruta, atunci trimitem un pachet de tip ICMP cu eroare de host unreachable. Dupa, facem un interface_mac de 6 octeti si il setam cu adresa MAC a interfetei rutei celei mai bune. Daca TTL este mai mic sau egal cu 1, atunci trimitem un pachet de ICMP cu eroare de time exceeded. Verificam apoi daca interfata IP-ului din pachet este egala cu adresa de destinatie a lui ip_hdr. Daca da, atunci trimitem un pachet de tip ICMP Echo Reply si terminam cu acel pachet. Altfel, scadem TTL-ul cu 1, setam checksumul la 0 si il recalculam. Apoi, vom apela 'get_arp_entry' pentru a gasi o intrare in tabela ARP pentru urmatorul hop al rutei celei mai bune. Daca nu gasim nicio intrare, atunci vom crea un nou buffer, cu marimea lenului dat in functia 'handle_packet', copiem bufferul vechi in bufferul nou si adaugam pachetul in coada de asteptare. Apoi, vom apela 'make_arp_request' pentru a trimite un pachet de tip ARP Request. Vom copia interface_mac in adresa MAC a sursei si adresa MAC a arp_entryului in adresa MAC a destinatiei si trimitem pachetul. Daca tipul de protocol este 0x0806(ETHERTYPE_ARP), atunci declaram arp_hdr si il setam la pachetul primit. Daca operatia este 1(ARP_REQUEST), atunci apelam 'arp_reply' pentru a trimite un pachet de tip ARP Reply. Daca operatia este 2(ARP_REPLY), atunci copiem adresa de hardware a sursei in tabela ARP, setam adresa IP a tabelei ARP ca fiind adresa IP a sursei si crestem arp_table_size cu 1. Apoi, cat timp coada de asteptare nu este goala, vom trimite pachetele din coada de asteptare in 'handle_packet'. Odata implementata, imi trece urmatoarele teste: forward, forward_no_arp, ttl, checksum, wrong_checksum, forward03, forward10, forward20, forward21, forward23 si forward31, plus celelalte teste mentionate anterior.

In main, vom declara o tabela de rutare cu 100000 de rute, marimea acelei tabele de rutare, folosind functia 'read_rtable'(din lib.c). Apoi, apelam qsort(rtable, rtable_size, sizeof(struct route_table_entry), compare), unde vom folosi functia de 'compare' pentru a sorta cum trebuie tabela de rutare. Dupa aceea, vom crea o tabela ARP cu 100000 de intrari, marimea acelei tabele ARP, fiind initial 0 si o coada. In while, vom apela 'handle_packet' pentru a procesa pachetele. Dupa ce am terminat de procesat pachetele, eliberam memoria pentru tabela de rutare si pentru tabela ARP.